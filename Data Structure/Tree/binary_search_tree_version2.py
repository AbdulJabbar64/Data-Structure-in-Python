# -*- coding: utf-8 -*-
"""Binary_Search_Tree_version2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aXwf2cBBY2qZQ9rui3xdfDk--9AiYPhT
"""

class Binary_Search_Tree:

    def __init__(self, data):
        self.data = data
        self.Left_child = None
        self.Right_child = None
       
    def Add_Node(self, data):
        if data < self.data:
            if self.Left_child:
                self.Left_child.Add_Node(data)
            else:
                self.Left_child = Binary_Search_Tree(data)         
        else:
            if self.Right_child:
                self.Right_child.Add_Node(data)
            else:
                self.Right_child = Binary_Search_Tree(data)


    def Find_Node(self, val):
        if self.data == val:
            return val
        
        if val < self.data:
            if self.Left_child:
                return self.Left_child.Find_Node(val)
            else:
                return "NOT FOUND"
        
        if val > self.data:
            if self.Right_child:
                return self.Right_child.Find_Node(val)
            else:
                return"NOT FOUND"
    
    def height(self, node):
        if node is None:
            return 0
        else :
            lheight = self.height(node.Left_child)
            rheight = self.height(node.Right_child)
        if lheight > rheight :
            return lheight+1
        else:
            return rheight+1

    def Level_Order_Traversal(self,root):
        elemt = []
        h = self.height(root)
        for i in range(1, h+1):
            self.printGivenLevel(root, i)
    
    def printGivenLevel(self, root , level):
        if root is None:
            return
        if level == 1:
            print(root.data,end=" ")
        elif level > 1 :
            self.printGivenLevel(root.Left_child , level-1)
            self.printGivenLevel(root.Right_child , level-1)
    
    def In_Order_Traversal(self):
        elements = []
        if self.Left_child:
            elements += self.Left_child.In_Order_Traversal()
        elements.append(self.data)
        if self.Right_child:
            elements += self.Right_child.In_Order_Traversal()
        return elements

    def Post_Order_Traversal(self):
        elements = []
        if self.Left_child:
            elements += self.Left_child.Post_Order_Traversal()
        if self.Right_child:
            elements += self.Right_child.Post_Order_Traversal()
        elements.append(self.data)
        return elements

    def Pre_Order_Traversal(self):
        elements = [self.data]
        if self.Left_child:
            elements += self.Left_child.Pre_Order_Traversal()
        if self.Right_child:
            elements += self.Right_child.Pre_Order_Traversal()
        return elements

    def Find_Maximum_Node(self):
        if self.Right_child is None:
            return self.data
        return self.Right_child.Find_Maximum_Node()
    
    def Find_Minimum_Node(self):
        if self.Left_child is None:
            return self.data
        return self.Left_child.Find_Minimum_Node()

    def Build_Tree(self,elements):
      root = Binary_Search_Tree(elements[0])
      for i in range(1,len(elements)):
          root.Add_Node(elements[i])
      return root

tree = Binary_Search_Tree(50)
tree.Add_Node(30)
tree.Add_Node(60)
tree.Add_Node(20)
tree.Add_Node(40)
tree.Add_Node(70)
tree.Level_Order_Traversal(tree)

